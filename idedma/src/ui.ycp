/**
 * File:
 *   include/idedma/ui.ycp
 *
 * Package:
 *   Configuration of IDE DMA mode
 *
 * Summary:
 *   User interface functions.
 *
 * Authors:
 *   Ladislav Slezak <lslezak@suse.cz>
 *
 * $Id$
 *
 * All user interface functions.
 *
 */

{

textdomain "tune";

import "Wizard";
import "Idedma";

import "Popup";
import "Label";
include "wizard/sequencer.ycp";

include "idedma/helps.ycp";

/**
 * String with DMA on status text
 * (For translators: translation can be long - text is used in the table
 * in column "Required DMA mode" and "Current DMA mode")
 */
string dma_on_string = _("On");

/**
 * String with DMA off status text
 * (For translators: translation can be long - text is used in the table
 * in column "Required DMA mode" and "Current DMA mode")
 */
string dma_off_string = _("Off");

/**
 * String with no change of DMA status text
 * (For translators: translation can be long - text is used in the table
 * in column "Required DMA mode" and "Current DMA mode")
 */
string dma_default_string = _("No change");


map mode_names = $[
    // DMA status is unknown
    ""      : _("Unknown"),
    // do not change DMA setting
    "nochange"	: dma_default_string,
    // DMA is enabled, but mode is unknown
    "on"    : dma_on_string,
    // DMA is disabled
    "off"   : dma_off_string,

    "sdma0" : "SW DMA/2.1",
    "sdma1" : "SW DMA/4.2",
    "sdma2" : "SW DMA/8.3",

    "mdma0" : "DMA/4.2",
    "mdma1" : "DMA/13.3",
    "mdma2" : "DMA/16",

    "udmaS" : "UltraDMA/13",
    "udma0" : "UltraDMA/16",
    "udma1" : "UltraDMA/22",
    "udma2" : "UltraDMA/33",
    "udma3" : "UltraDMA/44",
    "udma4" : "UltraDMA/66",
    "udma5" : "UltraDMA/100",
    "udma6" : "UltraDMA/133"
];


/**
 * Return list of items for table widget
 * @return list List of items
 */
define list get_table_items() ``{
    list<map> ide = Idedma::get_ide_devices();

    // prepare table items
    list table_items = [];
    integer id = 0;

    foreach(map d, ide, ``{
	    string mode = d["dma_setting"]:"";
	    string dma = Idedma::mode_names[mode]:(Idedma::dma_default_string);

	    // current DMA mode is unknown
	    string current_dma = d["current_dma"]:"";
	    current_dma = Idedma::mode_names[current_dma]:_("Unknown");

	    // device model name is unknown
	    string device_name = d["device"]:_("Unknown device");
	    // device file name is unknown
	    string device = d["dev_name"]:_("Unknown");

	    // add scsi device name for ide-scsi devices
	    if (d["scsi_name"]:nil != nil)
	    {
		// device model name is unknown
		device = sformat("%1 (%2)", device, d["scsi_name"]:_("Unknown device"));
	    }

	    // device type (disk, cdrom,...) is unknown
	    string device_type = d["device_type"]:_("Unknown type");

	    table_items = add(table_items, `item(`id(id), current_dma, device_name, device_type, device, dma));

	    id = id + 1;
	}
    );

    return table_items;
}

/**
 * Refresh combo widget content for actual selected device in the table
 */
define void refresh_combo() ``{
    // set DMA status for selected IDE device
    integer curr = (integer) UI::QueryWidget(`id(`device_table), `CurrentItem);

    if (curr != nil)
    {
	list<map> ide_devs = Idedma::get_ide_devices();

	// get device name from the table
	string dn = (string) (ide_devs[curr, "dev_name"]:nil);

	// get current setting
	string current = Idedma::selected_mode(dn);
	y2milestone("current(%2): %1", current, dn);

	// get list of supported DMA modes for selected device
	list supported_dma_modes = Idedma::supported_dma_modes(dn);

	list combo_list = [
	    `item(`id(`nochange), _("No change"), current == "nochange"),
	    `item(`id(`off), _("DMA Off"), current == "off"),
	    `item(`id(`on), _("DMA On (default mode)"), current == "on"),
	];

	if (contains(supported_dma_modes, "mdma2"))
	{
	    combo_list = add(combo_list, `item(`id(`mdma2), "DMA/16", current == "mdma2"));
	}
	if (contains(supported_dma_modes, "udma0"))
	{
	    combo_list = add(combo_list, `item(`id(`udma0), "UltraDMA/16", current == "udma0"));
	}
	if (contains(supported_dma_modes, "udma2"))
	{
	    combo_list = add(combo_list, `item(`id(`udma2), "UltraDMA/33", current == "udma2"));
	}
	if (contains(supported_dma_modes, "udma4"))
	{
	    combo_list = add(combo_list, `item(`id(`udma4), "UltraDMA/66", current == "udma4"));
	}
	if (contains(supported_dma_modes, "udma5"))
	{
	    combo_list = add(combo_list, `item(`id(`udma5), "UltraDMA/100", current == "udma5"));
	}
	if (contains(supported_dma_modes, "udma6"))
	{
	    combo_list = add(combo_list, `item(`id(`udma6), "UltraDMA/133", current == "udma6"));
	}

	y2milestone("combo: %1", combo_list);

	UI::ReplaceWidget(`id(`rp), `ComboBox(`id(`dma_combo), `opt(`notify), _("&DMA Mode:"), combo_list));
    }
    else
    {
	UI::ReplaceWidget(`id(`rp), `ComboBox(`id(`dma_combo), _("&DMA Mode:"), []));
    }
}

/**
 * Main DMA configuration dialog
 * @return any Result from UserInput()
 */
define any DmaConfigDialog () ``{
    // dialog header
    string caption = _("IDE DMA setup");
    boolean changed = false;
    list items = get_table_items();

    term contents = `VBox(
			// table header
			`Table(`id(`device_table), `opt(`notify, `immediate),
			    `header(_("Current DMA mode"), _("Device name"), _("Type"),
			    _("Device"), _("Required DMA mode")), items),
			`ReplacePoint(`id(`rp), `Empty()),
			`VSpacing(0.5)
		    );

    Wizard::SetContents(caption,
	contents,
	DetectedDialogHelp(),
	false, true
    );

    // remove Back button - workflow has only one dialog
    Wizard::ReplaceBackButton(`Empty());
    Wizard::ReplaceNextButton(`PushButton(`id(`next), `opt(`default, `key_F10), Label::FinishButton()));

    // set combo widget content
    refresh_combo();

    list<map> ide_devs = Idedma::get_ide_devices();

    any ret = nil;
    while (true)
    {
	ret = UI::UserInput();

	y2milestone("ui: %1", ret);

	if (ret == `dma_combo)
	{
	    y2milestone("Value changed");

	    // set DMA status for selected IDE device
	    integer curr = (integer) UI::QueryWidget(`id(`device_table), `CurrentItem);

	    y2milestone("curr: %1", curr);

	    if (curr != nil)
	    {
		// get device name
		string dn = (string) (ide_devs[curr, "dev_name"]:nil);
		// get current DMA
		string curr_dma = (string) (ide_devs[curr, "current_dma"]:nil);

		y2milestone("dn: %1", dn);

		if (dn != nil)
		{
		    string new_setting = sformat("%1", UI::QueryWidget(`id(`dma_combo), `Value));

		    if (size(new_setting) > 1 && substring(new_setting, 0, 1) == "`")
		    {
			new_setting = substring(new_setting, 1);
		    }
		    y2debug("ret: %1, curr_dma: %2, new_setting: %3", ret, curr_dma, new_setting);

		    // enabling DMA on device with currnet DMA off
		    if (ret == `dma_combo && curr_dma == "off" && new_setting != "off" && new_setting != "nochange")
		    {
			// warning popup message
			Popup::Warning(_("Enabling DMA on some devices can cause\ndata loss or system lock."));
		    }

		    // convert button identification to DMA boolean value

		    y2milestone(new_setting);
		    // set DMA
		    Idedma::set_dma(dn, new_setting);

		    // refresh value in the table
		    UI::ChangeWidget(`id(`device_table), `Item(curr, 4), Idedma::mode_names[new_setting]:_("No change"));
		}
	    }
	}
	else if (ret == `next || ret == `abort)
	{
	    break;
	}
	else if (ret == `device_table)
	{
	    // selected item was changed
	    refresh_combo();
	}
	else if (ret == `cancel)
	{
	    if (changed == true)
	    {
		if (Popup::ReallyAbort(true) == false)
		{
		    continue;
		}
	    }
	    ret = `abort;
	    break;
	}
    };

    return ret;
}

/**
 * Main workflow of the idedma configuration
 * @return any Result from WizardSequencer() function
 */
define any MainSequence () ``{
    map aliases =
	$[
	    "dmaconfig"	:   ``( DmaConfigDialog () ),
	];

    map sequence = $[
	"ws_start" : "dmaconfig",
	"dmaconfig" :
	$[
	    `abort	: `abort,
	    `next	: `next,
	],
    ];

    any ret = WizardSequencer (aliases, sequence);

    return ret;
}

/**
 * Read settings dialog
 * @return symbol `abort if configuration read failed
 */
define symbol ReadDialog () ``{
    // Set help text
    Wizard::RestoreHelp (ReadDialogHelp ());

    // Read the configuration
    boolean was_ok = Idedma::Read();

    return ( was_ok? `next : `abort );
}

/**
 * Write settings dialog
 * @return symbol `abort if configuration write failed
 */
define symbol WriteDialog () ``{
    // Set help text
    Wizard::RestoreHelp (WriteDialogHelp ());

    // Read the configuration
    boolean was_ok = Idedma::Write();

    return ( was_ok? `next : `abort );
}

/**
 * Whole configuration of DMA
 * @return any Result from WizardSequencer() function
 */
define any IdedmaSequence() ``{
    map aliases =
	$[
	    "read"	: [ ``( ReadDialog () ), true ],
	    "main"	:   ``( MainSequence () ),
	    "write"	: [ ``( WriteDialog () ), true ]
	];

    map sequence = $[
	"ws_start" : "read",
	"read" :
	$[
	    `abort	: `abort,
	    `next	: "main"
	],
	"main" :
	$[
	    `abort	: `abort,
	    `next	: "write"
	],
	"write" : $[
	    `abort	: `abort,
	    `next	: `next
	]
    ];

    Wizard::CreateDialog();

    any ret = WizardSequencer(aliases, sequence);

    UI::CloseDialog();
    return ret;
}

/**
 * Whole configuration of DMA but without reading and writing.
 * For use with autoinstallation.
 * @return any Result from WizardSequencer() function
 */
define any IdedmaAutoSequence () ``{
    // dialog header
    string caption = _("IDE DMA setup");
    // progress label
    term contents = `Label (_("Initializing ..."));

    Wizard::CreateDialog ();
    Wizard::SetContentsButtons ( caption,
				contents,
				"",
				Label::BackButton (),
				Label::NextButton ());

    // Run the main configuration workflow
    any ret = MainSequence ();

    UI::CloseDialog ();
    return ret;
}

}
