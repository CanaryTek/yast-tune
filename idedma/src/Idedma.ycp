/**
 * File:
 *   modules/Idedma.ycp
 *
 * Package:
 *   Configuration of IDE DMA mode
 *
 * Summary:
 *   Data for configuration of IDE DMA mode, input and output functions.
 *
 * Authors:
 *   Ladislav Slezak <lslezak@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of IDE DMA mode.
 * Input and output routines.
 *
 */

{
    // Set the name of the module
    module "Idedma";
    import "Report";
    import "Runlevel";

    include "hwinfo/classnames.ycp";

    textdomain "tune";

    // Settings: Define all variables needed for configuration of IDE DMA

    /**
     * List of all IDE devices with descriptions and DMA settings
     */
    list ide_devices = [];

    /**
     * Full path to hdparm binary
     */
    string hdparm_bin = "/sbin/hdparm";

    /**
     * Read all DMA settings from the SCR
     * @return boolean true on success
     */
    global define boolean Read() ``{
	ide_devices = [];

	// read information about all IDE devices
	list devices = SCR::Read(.probe.ide);

	// read setting from sysconfig
	string devices_setting_str = SCR::Read(.sysconfig.hardware.DEVICES_FORCE_IDE_DMA);

	y2debug("Read configuration: %1", devices_setting_str);

	if (devices_setting_str == nil)
	{
	    devices_setting_str = "";
	}


	// split string to list of devices
	list device_settings = splitstring(devices_setting_str, " ");

	// create map of settings <device>:<DMA_setting>
	map device_setting_map = listmap(string setting, device_settings,
	    ``{
		string dev = regexpsub(setting, "^(.*):(.*)", "\\1");
		string dma = regexpsub(setting, "^(.*):(.*)", "\\2");

		return [dev, dma];
	    }
	);

	y2milestone("Read config: %1", device_setting_map);

	// for each detected IDE device build internal
	foreach(`dev, devices, ``{
		// device model name is unknown
		string device = lookup(dev, "device", _("Unknown device"));
		string dev_name = lookup(dev, "dev_name", nil);

		if (dev_name != nil)
		{
		    integer subclass_id = lookup(dev, "sub_class_id", nil);
		    integer class_id = lookup(dev, "class_id", nil);

		    string dma_setting = device_setting_map[dev_name]:"nochange";
		    string dev_name_base = substring(dev_name, findlastof(dev_name, "/") + 1);

		    // get textual information about device type (disk, CD-ROM, tape, ...) from identification number - device type was not found
		    string subclass_id_string = eval(lookup(lookup(ClassNames, class_id, $[]), subclass_id, _("Unknown device type")));

		    // get current DMA setting
		    string current_dma = get_device_dma_status(dev_name);
		    string dma_info = get_dma_info(dev_name);

		    y2milestone("dma_info: %1", dma_info);

		    string current_dma_string = get_current_dma_mode(dma_info);
		    if (current_dma == "on" && size(current_dma_string) > 0)
		    {
			current_dma = current_dma_string;
		    }

		    list(string) dma_modes = get_supported_dma_modes(dma_info);

		    ide_devices = add(ide_devices, $["device" : device, "dev_name" : dev_name, "dma_setting" : dma_setting, "device_type" : subclass_id_string, "current_dma" : current_dma, "dma_modes" : dma_modes]);
		}
	    }
	);

	y2debug("IDE devices: %1", ide_devices);
	y2milestone("IDE devices: %1", ide_devices);

	return true;
    }


    /**
     * Return information about all IDE devices
     * @return list List of maps with information about all IDE devices
     */
    global define list get_ide_devices() ``{
	return ide_devices;
    }

    /**
     * Get list of supported DMA modes for selected device
     * @param device device name ("/dev/hda")
     * @return list supported DMA modes (["mdma2", "udma0", "udma1", "udma2"])
     */
    global define list supported_dma_modes(string device) ``{
	list result = [];

	if (size(device) > 0)
	{
	    foreach(map info, ide_devices, ``{
		    if (info["dev_name"]:"" == device)
		    {
			result = info["dma_modes"]:[];
		    }
		}
	    );
	}

	return result;
    }

    /**
     * Get selected DMA mode, which will be saved and set in Write
     * @param device device name ("/dev/hda")
     * @return string selected DMA mode ("on", "off", "nochange", or mode supported by hdparm - "udma5",...)
     */
    global define string selected_mode(string device) ``{
	string mode = "";

	if (size(device) > 0)
	{
	    foreach(map info, ide_devices, ``{
		    if (info["dev_name"]:"" == device)
		    {
			mode = info["dma_setting"]:"";
		    }
		}
	    );
	}

	return mode;
    }

    /**
     * Return actual DMA status of IDE device
     * @param device Identification of ide device, e.g. "/dev/hdc"
     * @return string true if DMA is on, false if DMA is off or nil on error
     */
    global define string get_device_dma_status(string device) ``{
	string result = "";

	if (device != nil && device != "")
	{
	    // run hdparm to get DMA status
	    map out = SCR::Execute(.target.bash_output, hdparm_bin + " -d " + device);

	    if (lookup(out, "exit", -1) == 0)
	    {
		list output = splitstring(out["stdout"]:"", "\n");

		y2debug("hdparm output: %1", output);

		// search for status string in output
		foreach(`l, output, ``{

			if (l == " using_dma    =  1 (on)")
			{
			    result = "on";

			}

			if (l == " using_dma    =  0 (off)")
			{
			    result = "off";
			}
		    }
		);
	    }
	}

	return result;
    }

    /**
     * Get DMA information status for device
     * @param device device name (e.g. "/dev/hdc")
     * @return string DMA information from hdparm ("mdma2 udma0 udma1 *udma2")
     */
    define string get_dma_info(string device) ``{
	string result = "";

	if (device != nil && device != "")
	{
	    // DMA mode is enabled, get DMA mode number
	    map out = SCR::Execute(.target.bash_output, hdparm_bin + " -I " + device);

	    if (out["exit"]:-1 == 0)
	    {
		list(string) output = splitstring(out["stdout"]:"", "\n");

		foreach(string line, output, ``{
			string dmaline = (regexpsub(line, "^[ \t]*DMA: (.*)$", "\\1"));

			if (dmaline != nil)
			{
			    result = dmaline;
			}
		    }
		);
	    }
	}
	return result;
    }


    /**
     * Parse DMA info string from hdparm output - return current DMA mode (has mark '*')
     * @param dma_info DMA support string (e.g. "mdma2 udma0 udma1 *udma2")
     * @return string current DMA mode or "" if unknown
     */
    define string get_current_dma_mode(string dma_info) ``{
	string result = "";

	if (dma_info != nil && dma_info != "")
	{
	    list modes = splitstring(dma_info, " ");

	    foreach(string mode, modes, ``{
		    string current = regexpsub(mode, "^\\*(.*)", "\\1");

		    if (current != nil)
		    {
			result = current;
		    }
		}
	    );
	}

	return result;
    }

    /**
     * Parse DMA info string from hdparm output - return list of supported DMA modes
     * @param dma_info DMA support string (e.g. "mdma2 udma0 udma1 *udma2")
     * @return list(string) list of supported DMA modes
     */
    define list(string) get_supported_dma_modes(string dma_info) ``{
	list result = [];

	if (dma_info != nil && dma_info != "")
	{
	    list modes = splitstring(dma_info, " ");

	    foreach(string mode, modes, ``{

		    if (size(mode) > 0)
		    {
			string current = regexpsub(mode, "^\\*(.*)", "\\1");

			// add mode or current mode (filter out * mark)
			result = add(result, (current != nil) ? current : mode);
		    }
		}
	    );
	}
	else
	{
	    // DMA info line is empty - no information is available
	    // offer all possible values
	    result = [ "mdma2", "udma0", "udma2", "udma4", "udma5", "udma6"];
	}

	return result;
    }


    /**
     * Refresh current DMA status stored in internal structure
     * @return void
     */
    global define void refresh_status() ``{
	// for each stored device get current DMA status
	ide_devices = maplist(`d, ide_devices, ``{
		string dev = lookup(d, "dev_name", nil);

		boolean status = get_device_dma_status(dev);

		// refresh value in map
		d = add(d, "current_dma", status);

		return d;
	    }
	);
    }

    /**
     * Set DMA of device
     * @param device Identification of IDE device, e.g. "/dev/hda"
     * @param dma_setting DMA mode (e.g. "mdma2", "udma5", "off",...)
     */
    global define void set_dma(string device, string dma_setting) ``{
	if (device == nil || dma_setting == nil)
	{
	    return;
	}

	// store required DMA status
	ide_devices = maplist(`d, ide_devices, ``{
		if (lookup(d, "dev_name", nil) == device)
		{
		    d = add(d, "dma_setting", dma_setting);
		}

		return d;
	    }
	);
    }

    /**
     * Update the SCR according to DMA settings
     * @return boolean true on success
     */
    global define boolean Write() ``{
	boolean ret = true;

	// create strings with device indentifications
	// e.g. new_dma_setting = "/dev/hda:udma5 /dev/hdc:off";
	string new_dma_setting = "";
	boolean first = true;
	boolean initscript_needed = false;

	y2milestone("ide_devices: %1", ide_devices);

	foreach(map d, ide_devices, ``{
		string d_name = d["dev_name"]:nil;

		if (d_name != nil)
		{
		    string dma_setting = d["dma_setting"]:"nochange";

		    string dma_current_setting = d["current_dma"]:"nochange";
		    string dma_required_setting = dma_setting;

		    if (dma_setting != "nochange")
		    {
			y2debug("d_name: %1  dma_setting: %2", d_name, dma_setting);
			dma_setting = d_name + ":" + dma_setting;

			if (first == true)
			{
			    new_dma_setting = dma_setting;
			    first = false;
			}
			else
			{
			    new_dma_setting = new_dma_setting + " " + dma_setting;
			}

			y2debug("dma_setting: %1, dma_current_setting: %2", dma_setting, dma_current_setting);

			// use boot.idedma only if current DMA mode and required DMA mode differ
			if (dma_required_setting != dma_current_setting &&
			    // don't distinguish between "on" and exact DMA mode
			    // (required is "on", current is not "off" nor "nochange" (it is e.g. "udma2"))
			    !(dma_required_setting == "on" && dma_current_setting != "off" && dma_current_setting != "nochange")
			)
			{
			    initscript_needed = true;
			}
		    }
		}
	    }
	);

	y2milestone("new_dma_setting: %1", new_dma_setting);

	// write device strings to sysconfig
	if (SCR::Write(.sysconfig.hardware.DEVICES_FORCE_IDE_DMA, new_dma_setting) == false)
	{
	    // error message
	    Report::Error(_("Unable to write settings to '/etc/sysconfig/hardware'."));
	    return false;
	}

	// flush changes
	SCR::Write(.sysconfig.hardware, nil);

	// activate settings
	if (initscript_needed == true)
	{
	    y2milestone("Executing /etc/init.d/boot.idedma start");

	    integer result = SCR::Execute(.target.bash, "/etc/init.d/boot.idedma start");

	    y2milestone("boot.idedma result: %1", result);

	    if (result != 0)
	    {
		// error message
		Report::Error(_("Error occurred while activating changes."));
		y2error("boot.idedma result: %1", result);
		ret = false;
	    }
	}

	if (new_dma_setting != "")
	{
	    // enable service
	    if (Runlevel::ServiceAdjust("boot.idedma", "default") != true)
	    {
		// error message
		Report::Error(_("Can not enable service 'boot.idedma'."));
		ret = false;
	    }
	}

	return ret;
    }

    /**
     * Get all IDE DMA  settings from the first parameter
     * (For use by autoinstallation.)
     * @param settings The YCP structure to be imported.
     * @return boolean True
     */
    global define boolean Import (list settings) ``{
	if (size(settings) == 0)
	{
	    return false;
	}

	Set(settings);
	return true;
    }

    /**
     * Set module data
     * @param settings set data from YCP
     * @return void
     */
    global define void Set (list settings) ``{

	ide_devices = settings;
	return;
    }

    /**
     * Dump the IDE DMA settings to a single map
     * (For use by autoinstallation.)
     * @return list Dumped settings (later acceptable by Import ())
     */
    global define list Export () ``{
	return ide_devices ;
    }

    /**
     * Set system configuration without reading values from
     * system - for testing and screenshot mode
     */
    global define void set_test_data() ``{
	ide_devices = [ $["current_dma":"udma2", "dev_name":"/dev/hda",
	    "device":"IBM-DJNA-351520", "device_type":"Disk", "dma_setting":"udma2"],
	    $["current_dma":"off", "dev_name":"/dev/hdc", "device":"CD-532E-B",
	    "device_type":"CD-ROM", "dma_on":"nochange"]
	];
    }

    /**
     * Build a textual summary that can be used e.g. in inst_hw_config () or
     * something similar.
     * @return string Summary of the configuration.
     */
    global define string Summary () ``{
	// TODO FIXME: your code here...
	return _("Summary of the configuration...");
    }

}
