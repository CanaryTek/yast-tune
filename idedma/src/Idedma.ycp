/**
 * File:
 *   modules/Idedma.ycp
 *
 * Package:
 *   Configuration of IDE DMA mode
 *
 * Summary:
 *   Data for configuration of IDE DMA mode, input and output functions.
 *
 * Authors:
 *   Ladislav Slezak <lslezak@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of IDE DMA mode.
 * Input and output routines.
 *
 */

{
    // Set the name of the module
    module "Idedma";
    import "Report";
    import "Runlevel";

    include "hwinfo/classnames.ycp";

    textdomain "tune";

    // Settings: Define all variables needed for configuration of IDE DMA

    /**
     * List of all IDE devices with descriptions and DMA settings
     */
    list ide_devices = [];

    /**
     * Full path to hdparm binary
     */
    string hdparm_bin = "/sbin/hdparm";

    /**
     * Read all DMA settings from the SCR
     * @return boolean true on success
     */
    global define boolean Read() ``{
	ide_devices = [];

	// read information about all IDE devices
	list devices = SCR::Read(.probe.ide);

	// read setting from sysconfig
	string devices_on_str = SCR::Read(.sysconfig.hardware.DEVICES_FORCE_IDE_DMA_ON);
	string devices_off_str = SCR::Read(.sysconfig.hardware.DEVICES_FORCE_IDE_DMA_OFF);

	y2debug("Read configuration: DMA_ON='%1', DMA_OFF='%2'", devices_on_str, devices_off_str);

	if (devices_off_str == nil)
	{
	    devices_off_str = "";
	}

	if (devices_on_str == nil)
	{
	    devices_on_str = "";
	}

	// split string to list of devices
	list devices_on = splitstring(devices_on_str, " ");
	list devices_off = splitstring(devices_off_str, " ");

	// for each detected IDE device build internal
	foreach(`dev, devices, ``{
		// device model name is unknown
		string device = lookup(dev, "device", _("Unknown device"));
		string dev_name = lookup(dev, "dev_name", nil);

		if (dev_name != nil)
		{
		    integer subclass_id = lookup(dev, "sub_class_id", nil);
		    integer class_id = lookup(dev, "class_id", nil);
		    boolean dma_on = nil;

		    string dev_name_base = substring(dev_name, findlastof(dev_name, "/") + 1);

		    // get status from sysconfig
		    if (contains(devices_on, dev_name_base))
		    {
			dma_on = true;
		    }

		    if (contains(devices_off, dev_name_base))
		    {
			dma_on = false;
		    }

		    // get textual information about device type (disk, CD-ROM, tape, ...) from identification number - device type was not found
		    string subclass_id_string = eval(lookup(lookup(ClassNames, class_id, $[]), subclass_id, _("Unknown device type")));

		    // get current DMA setting
		    string current_dma = get_device_dma_status(dev_name);
		    string dma_info = get_dma_info(dev_name);

		    y2milestone("dma_info: %1", dma_info);

		    string current_dma_string = get_current_dma_mode(dma_info);
		    if (current_dma == "on" && size(current_dma_string) > 0)
		    {
			current_dma = current_dma_string;
		    }

		    list(string) dma_modes = get_supported_dma_modes(dma_info);

		    ide_devices = add(ide_devices, $["device" : device, "dev_name" : dev_name, "dma_on" : dma_on, "device_type" : subclass_id_string, "current_dma" : current_dma, "dma_modes" : dma_modes]);
		}
	    }
	);

	y2debug("IDE devices: %1", ide_devices);
	y2milestone("IDE devices: %1", ide_devices);

	return true;
    }


    /**
     * Return information about all IDE devices
     * @return list List of maps with information about all IDE devices
     */
    global define list get_ide_devices() ``{
	return ide_devices;
    }

    global define list supported_dma_modes(string device) ``{
	list result = [];

	foreach(map info, ide_devices, ``{
		if (info["dev_name"]:"" == device)
		{
		    result = info["dma_modes"]:[];
		}
	    }
	);

	return result;
    }

    /**
     * Return actual DMA status of IDE device
     * @param device Identification of ide device, e.g. "/dev/hdc"
     * @return boolean true if DMA is on, false if DMA is off or nil on error
     */
    global define string get_device_dma_status(string device) ``{
	string result = "";

	if (device != nil && device != "")
	{
	    // run hdparm to get DMA status
	    map out = SCR::Execute(.target.bash_output, hdparm_bin + " -d " + device);

	    if (lookup(out, "exit", -1) == 0)
	    {
		list output = splitstring(out["stdout"]:"", "\n");

		y2debug("hdparm output: %1", output);

		// search for status string in output
		foreach(`l, output, ``{

			if (l == " using_dma    =  1 (on)")
			{
			    result = "on";

			}

			if (l == " using_dma    =  0 (off)")
			{
			    result = "off";
			}
		    }
		);
	    }
	}

	return result;
    }

    define string get_dma_info(string device) ``{
	string result = "";

	if (device != nil && device != "")
	{
	    // DMA mode is enabled, get DMA mode number
	    map out = SCR::Execute(.target.bash_output, hdparm_bin + " -I " + device);

	    if (out["exit"]:-1 == 0)
	    {
		list(string) output = splitstring(out["stdout"]:"", "\n");

		foreach(string line, output, ``{
			string dmaline = (regexpsub(line, "^[ \t]*DMA: (.*)$", "\\1"));

			if (dmaline != nil)
			{
			    result = dmaline;
			}
		    }
		);
	    }
	}
	return result;
    }


    define string get_current_dma_mode(string dma_info) ``{
	string result = "";

	if (dma_info != nil && dma_info != "")
	{
	    list modes = splitstring(dma_info, " ");

	    foreach(string mode, modes, ``{
		    string current = regexpsub(mode, "^\\*(.*)", "\\1");

		    if (current != nil)
		    {
			result = current;
		    }
		}
	    );
	}

	return result;
    }

    define list(string) get_supported_dma_modes(string dma_info) ``{
	list result = [];

	if (dma_info != nil && dma_info != "")
	{
	    list modes = splitstring(dma_info, " ");

	    foreach(string mode, modes, ``{

		    if (size(mode) > 0)
		    {
			string current = regexpsub(mode, "^\\*(.*)", "\\1");

			// add mode or current mode (filter out * mark)
			result = add(result, (current != nil) ? current : mode);
		    }
		}
	    );
	}

	return result;
    }


    /**
     * Refresh current DMA status stored in internal structure
     * @return void
     */
    global define void refresh_status() ``{
	// for each stored device get current DMA status
	ide_devices = maplist(`d, ide_devices, ``{
		string dev = lookup(d, "dev_name", nil);

		boolean status = get_device_dma_status(dev);

		// refresh value in map
		d = add(d, "current_dma", status);

		return d;
	    }
	);
    }

    /**
     * Set DMA of device
     * @param device Identification of IDE device, e.g. "/dev/hda"
     * @param dma_on true - set DMA on, false - set DMA off, nil - no change of DMA
     */
    global define void set_dma(string device, string dma_setting) ``{
	if (device == nil)
	{
	    return;
	}

	// store required DMA status
	ide_devices = maplist(`d, ide_devices, ``{
		if (lookup(d, "dev_name", nil) == device)
		{
		    d = add(d, "dma_setting", dma_setting);
		}

		return d;
	    }
	);
    }

    /**
     * Update the SCR according to DMA settings
     * @return boolean true on success
     */
    global define boolean Write() ``{
	boolean ret = true;

	// create strings with device indentifications
	// e.g. dma_on_string = "hda hdc";
	string dma_on_string = "";
	string dma_off_string = "";

	boolean first_on = true;
	boolean first_off = true;

	foreach(`d, ide_devices, ``{
		string d_name = lookup(d, "dev_name", nil);
		string dev_name_base = substring(d_name, findlastof(d_name, "/") + 1);

		if (d_name != nil)
		{
		    string dma_setting = lookup(d, "dma_setting", "");
		    string dma_str = "''";

/*		    if (dma_on == true)
		    {
			if (first_on == true)
			{
			    dma_on_string = dev_name_base;
			    first_on = false;
			}
			else
			{
			    dma_on_string = dma_on_string + " " + dev_name_base;
			}

			dma_str = "1";
		    }
		    else if (dma_on == false)
		    {
			if (first_off == true)
			{
			    dma_off_string = dev_name_base;
			    first_off = false;
			}
			else
			{
			    dma_off_string = dma_off_string + " " + dev_name_base;
			}

			dma_str = "0";
		    }

		    if (dma_on != nil)
		    {
			SCR::Execute(.target.bash, hdparm_bin + " -d " + dma_str + " " + d_name);
			boolean actual = get_device_dma_status(d_name);

			if (dma_on != actual)
			{
			    // error message - %1 is device file (e.g. /dev/hda), %2 is 0 (DMA disabled) or 1 (DMA enabled)
			    Report::Error(sformat(_("Device %1: Can not set DMA to value %2"), d_name, dma_str));
			    ret = false;
			}
		    }*/
		}
	    }
	);

	y2debug("DMA on: %1", dma_on_string);
	y2debug("DMA off: %1", dma_off_string);

	// write device strings to sysconfig
	if ((SCR::Write(.sysconfig.hardware.DEVICES_FORCE_IDE_DMA_ON, dma_on_string)
	    && SCR::Write(.sysconfig.hardware.DEVICES_FORCE_IDE_DMA_OFF, dma_off_string)) == false)
	{
	    // error message
	    Report::Error(_("Unable to write settings to '/etc/sysconfig/hardware'."));
	    ret = false;
	}


	// enable service
	if (Runlevel::ServiceAdjust("boot.idedma", "default") != true)
	{
	    // error message
	    Report::Error(_("Can not enable service 'boot.idedma'."));
	    ret = false;
	}

	return ret;
    }

    /**
     * Get all IDE DMA  settings from the first parameter
     * (For use by autoinstallation.)
     * @param settings The YCP structure to be imported.
     * @return boolean True
     */
    global define boolean Import (list settings) ``{
	if (size(settings) == 0)
	{
	    return false;
	}

	Set(settings);
	return true;
    }

    /**
     * Set module data
     * @param void
     * @return void
     */ 
    global define void Set (list settings) ``{

	ide_devices = settings;
	return;
    }
    
    /**
     * Dump the IDE DMA settings to a single map
     * (For use by autoinstallation.)
     * @return list Dumped settings (later acceptable by Import ())
     */
    global define list Export () ``{
	return ide_devices ;
    }

    /**
     * Set system configuration without reading values from
     * system - for testing and screenshot mode
     */
    global define void set_test_data() ``{
	ide_devices = [ $["current_dma":true, "dev_name":"/dev/hda",
	    "device":"IBM-DJNA-351520", "device_type":"Disk", "dma_setting":""],
	    $["current_dma":true, "dev_name":"/dev/hdc", "device":"CD-532E-B",
	    "device_type":"CD-ROM", "dma_on":nil]
	];
    }

    /**
     * Build a textual summary that can be used e.g. in inst_hw_config () or
     * something similar.
     * @return string Summary of the configuration.
     */
    global define string Summary () ``{
	// TODO FIXME: your code here...
	return _("Summary of the configuration...");
    }

}
